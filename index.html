<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vermont State Legislative Board Game Night</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        h1 {
            text-align: center;
            color: white;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }
        
        .section {
            background: white;
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 25px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.1);
        }
        
        .section h2 {
            color: #667eea;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #667eea;
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            color: #333;
            font-weight: 500;
        }
        
        input[type="text"],
        input[type="number"],
        input[type="date"],
        select {
            width: 100%;
            padding: 10px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            font-size: 14px;
            transition: border-color 0.3s;
        }
        
        input[type="text"]:focus,
        input[type="number"]:focus,
        input[type="date"]:focus,
        select:focus {
            outline: none;
            border-color: #667eea;
        }
        
        input[type="checkbox"] {
            margin-right: 8px;
            width: 18px;
            height: 18px;
            cursor: pointer;
        }
        
        .checkbox-label {
            display: flex;
            align-items: center;
            cursor: pointer;
        }
        
        button {
            background: #667eea;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        button:hover {
            background: #5568d3;
        }
        
        button.danger {
            background: #e74c3c;
        }
        
        button.danger:hover {
            background: #c0392b;
        }
        
        button.secondary {
            background: #95a5a6;
        }
        
        button.secondary:hover {
            background: #7f8c8d;
        }
        
        .game-list {
            display: grid;
            gap: 15px;
        }
        
        .game-item {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #667eea;
            position: relative;
        }
        
        .game-item .delete-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #e74c3c;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            display: none;
        }
        
        .game-item .delete-btn:hover {
            background: #c0392b;
        }
        
        .game-item .edit-link-btn {
            position: absolute;
            top: 10px;
            right: 80px;
            background: #3498db;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            display: none;
        }
        
        .game-item .edit-link-btn:hover {
            background: #2980b9;
        }
        
        .admin-mode .game-item .delete-btn,
        .admin-mode .game-item .edit-link-btn {
            display: block;
        }
        
        .game-item .bgg-link {
            display: inline-block;
            margin-top: 8px;
            color: #667eea;
            text-decoration: none;
            font-size: 13px;
        }
        
        .game-item .bgg-link:hover {
            text-decoration: underline;
        }
        
        .voting-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin-top: 20px;
        }
        
        .voting-card {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #e0e0e0;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            transform: translateY(0);
        }
        
        .voting-card:hover {
            border-color: #667eea;
            box-shadow: 0 6px 12px rgba(102, 126, 234, 0.25);
            transform: translateY(-4px);
        }
        
        .voting-card.selected {
            border-color: #667eea;
            background: #e8eaf6;
            box-shadow: 0 4px 8px rgba(102, 126, 234, 0.3);
        }
        
        .voting-card.selected:hover {
            transform: translateY(-2px);
        }
        
        .voting-card .rank-badge {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #667eea;
            color: white;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: none;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 18px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .voting-card.selected .rank-badge {
            display: flex;
        }
        
        .voting-card h4 {
            color: #333;
            margin-bottom: 8px;
            margin-right: 40px;
        }
        
        .voting-card .card-detail {
            color: #666;
            font-size: 13px;
            margin: 4px 0;
        }
        
        .selection-counter {
            background: #fff3cd;
            border: 2px solid #ffc107;
            border-radius: 6px;
            padding: 12px;
            margin: 15px 0;
            text-align: center;
            font-weight: 600;
            color: #856404;
        }
        
        .selection-counter.complete {
            background: #d4edda;
            border-color: #4caf50;
            color: #155724;
        }
        
        .save-status {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: white;
            padding: 12px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            display: none;
            align-items: center;
            gap: 10px;
            z-index: 1000;
            font-weight: 600;
            font-size: 14px;
        }
        
        .save-status.saving {
            display: flex;
            background: #e3f2fd;
            color: #1976d2;
            border: 2px solid #2196f3;
        }
        
        .save-status.success {
            display: flex;
            background: #d4edda;
            color: #155724;
            border: 2px solid #4caf50;
        }
        
        .save-status.error {
            display: flex;
            background: #f8d7da;
            color: #721c24;
            border: 2px solid #e74c3c;
        }
        
        .save-status .spinner {
            width: 16px;
            height: 16px;
            border: 3px solid #1976d2;
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .retry-button {
            background: #e74c3c;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
        }
        
        .retry-button:hover {
            background: #c0392b;
        }
        
        .voting-explanation {
            background: #e3f2fd;
            border-left: 4px solid #2196f3;
            padding: 12px 15px;
            margin: 15px 0;
            border-radius: 4px;
            font-size: 14px;
            color: #0d47a1;
        }
        
        .game-night-info {
            background: #e8f5e9;
            border: 2px solid #4caf50;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            text-align: center;
        }
        
        .game-night-info h3 {
            color: #2e7d32;
            margin-bottom: 10px;
        }
        
        .game-night-info .info-detail {
            font-size: 16px;
            color: #333;
            margin: 5px 0;
        }
        
        .manage-games-section {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 2px solid #e0e0e0;
        }
        
        .game-management-grid {
            display: grid;
            gap: 12px;
            margin-top: 15px;
        }
        
        .game-mgmt-item {
            background: #f8f9fa;
            padding: 12px;
            border-radius: 6px;
            border-left: 4px solid #667eea;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .game-mgmt-info {
            flex: 1;
        }
        
        .game-mgmt-info h4 {
            margin: 0 0 4px 0;
            color: #333;
            font-size: 16px;
        }
        
        .game-mgmt-info .mgmt-detail {
            font-size: 13px;
            color: #666;
            margin: 2px 0;
        }
        
        .game-mgmt-actions {
            display: flex;
            gap: 8px;
        }
        
        .game-mgmt-actions button {
            padding: 6px 12px;
            font-size: 12px;
        }
        
        @media (max-width: 1200px) {
            .voting-grid {
                grid-template-columns: repeat(3, 1fr);
            }
        }
        
        @media (max-width: 900px) {
            .voting-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }
        
        @media (max-width: 600px) {
            .voting-grid {
                grid-template-columns: 1fr;
            }
        }
        
        .game-item h3 {
            color: #333;
            margin-bottom: 8px;
        }
        
        .game-detail {
            color: #666;
            font-size: 14px;
            margin: 4px 0;
        }
        
        .rank-selector {
            display: grid;
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .rank-item {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .rank-item label {
            min-width: 100px;
            margin: 0;
        }
        
        .rank-item select {
            flex: 1;
        }
        
        .winner-section {
            background: #fff9e6;
            padding: 20px;
            border-radius: 8px;
            border: 2px solid #ffd700;
            margin-top: 20px;
        }
        
        .winner-section h3 {
            color: #f39c12;
            margin-bottom: 15px;
        }
        
        .player-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 8px;
        }
        
        .player-badge {
            background: #667eea;
            color: white;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 13px;
        }
        
        .history-item {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
        }
        
        .history-item h4 {
            color: #667eea;
            margin-bottom: 10px;
        }
        
        .admin-controls {
            display: grid;
            gap: 15px;
        }
        
        .voting-status {
            padding: 10px;
            border-radius: 6px;
            text-align: center;
            font-weight: 600;
            margin-bottom: 15px;
        }
        
        .voting-open {
            background: #d4edda;
            color: #155724;
        }
        
        .voting-closed {
            background: #f8d7da;
            color: #721c24;
        }
        
        .warning {
            background: #fff3cd;
            border: 1px solid #ffc107;
            color: #856404;
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 15px;
        }
        
        .overflow-indicator {
            color: #e74c3c;
            font-size: 13px;
            font-style: italic;
            margin-top: 4px;
        }
        
        .two-column {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }
        
        @media (max-width: 768px) {
            .two-column {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üé≤ Vermont State Legislative Board Game Night</h1>
        
        <!-- Save Status Indicator -->
        <div id="saveStatus" class="save-status">
            <div class="spinner"></div>
            <span id="saveStatusText">Saving...</span>
        </div>
        
        <!-- Voting -->
        <div class="section">
            <h2>üó≥Ô∏è Vote for This Week's Games</h2>
            
            <!-- Game Night Info -->
            <div id="gameNightInfo" class="game-night-info"></div>
            
            <div id="votingWarning" class="warning" style="display: none;"></div>
            <div class="form-group">
                <label for="voterName">Your Name:</label>
                <input type="text" id="voterName" placeholder="Enter your name">
            </div>
            
            <div class="voting-explanation">
                <strong>How voting works:</strong> Your 1st choice gets 3 points, 2nd choice gets 2 points, and 3rd choice gets 1 point. The three games with the most points win!
            </div>
            
            <p style="margin: 15px 0; color: #666;">Click on 3 games in order of preference (1st, 2nd, 3rd choice):</p>
            
            <div id="selectionCounter" class="selection-counter"></div>
            
            <div id="votingGrid" class="voting-grid"></div>
            
            <button onclick="submitVote()" style="margin-top: 20px;">Submit Vote</button>
        </div>
        
        <!-- This Week's Games -->
        <div class="section">
            <h2>üèÜ This Week's Top Games</h2>
            <div id="topGames"></div>
        </div>
        
        <!-- Add Games -->
        <div class="section">
            <h2>‚ûï Add a Game</h2>
            <div class="form-group">
                <label for="ownerName">Your Name:</label>
                <input type="text" id="ownerName" placeholder="Enter your name">
            </div>
            <div class="form-group">
                <label for="gameName">Game Name:</label>
                <input type="text" id="gameName" placeholder="Enter game name">
            </div>
            <div class="form-group">
                <label for="bggLink">BoardGameGeek Link (optional):</label>
                <input type="text" id="bggLink" placeholder="https://boardgamegeek.com/boardgame/...">
            </div>
            <div class="two-column">
                <div class="form-group">
                    <label for="minPlayers">Min Players:</label>
                    <input type="number" id="minPlayers" min="1" value="2">
                </div>
                <div class="form-group">
                    <label for="maxPlayers">Max Players:</label>
                    <input type="number" id="maxPlayers" min="1" value="4">
                </div>
            </div>
            <div class="form-group">
                <label for="gameLength">Game Length (minutes, optional):</label>
                <input type="number" id="gameLength" placeholder="e.g., 60" min="1">
            </div>
            <div class="form-group">
                <label class="checkbox-label">
                    <input type="checkbox" id="canTeach">
                    I can teach this game
                </label>
            </div>
            <button onclick="addGame()">Add Game</button>
        </div>
        
        <!-- History -->
        <div class="section">
            <h2>üìú Game Night History</h2>
            <div id="winnerRecordingSection" class="winner-section" style="display: none;">
                <h3>Record Winner for Current Week</h3>
                <div class="form-group">
                    <label for="winnerGame">Select Game:</label>
                    <select id="winnerGame">
                        <option value="">Select a game</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="winnerName">Winner Name:</label>
                    <input type="text" id="winnerName" placeholder="Enter winner's name">
                </div>
                <div class="form-group">
                    <label for="winnerDate">Date Played:</label>
                    <input type="date" id="winnerDate">
                </div>
                <button onclick="recordWinner()">Record Winner</button>
            </div>
            
            <div id="historyList" style="margin-top: 20px;"></div>
        </div>
        
        <!-- Admin Controls -->
        <div class="section">
            <h2>‚öôÔ∏è Admin Controls</h2>
            <div id="adminLogin" style="display: block;">
                <div class="form-group">
                    <label for="adminPassword">Admin Password:</label>
                    <input type="password" id="adminPassword" placeholder="Enter admin password">
                </div>
                <button onclick="adminLogin()">Login as Admin</button>
            </div>
            <div id="adminPanel" style="display: none;">
                <div style="background: #d4edda; padding: 10px; border-radius: 6px; margin-bottom: 15px; color: #155724;">
                    ‚úì Logged in as Admin
                    <button onclick="adminLogout()" class="secondary" style="float: right; padding: 6px 12px;">Logout</button>
                </div>
                <div class="admin-controls">
                    <div class="form-group">
                        <label for="gameNightDate">Game Night Date:</label>
                        <input type="date" id="gameNightDate">
                    </div>
                    <div class="form-group">
                        <label for="votingDeadline">Voting Deadline:</label>
                        <input type="date" id="votingDeadline">
                    </div>
                    <button onclick="saveGameNightDates()">Set Dates</button>
                    <button class="danger" onclick="resetForNewWeek()">Reset for New Week</button>
                    
                    <!-- Game Management Section -->
                    <div class="manage-games-section">
                        <h3 style="color: #667eea; margin-bottom: 10px;">Manage Games</h3>
                        <div id="gameManagementGrid" class="game-management-grid"></div>
                    </div>
                    
                    <div class="form-group" style="margin-top: 20px;">
                        <label for="newAdminPassword">Change Admin Password:</label>
                        <input type="password" id="newAdminPassword" placeholder="Enter new password">
                        <button onclick="changeAdminPassword()" style="margin-top: 10px;">Update Password</button>
                    </div>
                </div>
            </div>
            <div id="votingStatus" class="voting-status"></div>
        </div>
    </div>

    <script>
        // Google Sheets API endpoint
        const SHEETS_API_URL = 'https://script.google.com/macros/s/AKfycbxgHEzu3nPSeGfYFPUwZT38CgTG3kHJBEcPvVxfKhKucx-pe1rVDos8dJkq9F7oA2Su/exec';

        // Initialize data structure
        let gameData = {
            games: [],
            votes: [],
            history: [],
            votingDeadline: null,
            gameNightDate: null,
            adminPassword: null,
            manualAssignments: {} // { "nameLower": gameId }
        };

        let isAdminLoggedIn = false;
        let lastSeatingState = { unassigned: [], seatNotes: {} }; // populated by calculateTopGames()
        let selectedVotes = [null, null, null]; // Track 1st, 2nd, 3rd choices
        let saveQueue = []; // Queue for failed saves
        let isSaving = false;

        // Show save status
        function showSaveStatus(status, message) {
            const statusDiv = document.getElementById('saveStatus');
            const statusText = document.getElementById('saveStatusText');
            
            statusDiv.className = `save-status ${status}`;
            statusText.textContent = message;
            
            if (status === 'success') {
                setTimeout(() => {
                    statusDiv.className = 'save-status';
                }, 3000);
            }
        }

        // Save data to Google Sheets with retry logic
        async function saveData(retryCount = 0) {
            const maxRetries = 3;
            
            if (isSaving && retryCount === 0) {
                // Already saving, add to queue
                console.log('Save already in progress, queueing...');
                return;
            }
            
            try {
                isSaving = true;
                showSaveStatus('saving', 'Saving...');
                
                console.log(`Attempting save (attempt ${retryCount + 1}/${maxRetries + 1})...`);
                
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 second timeout
                
                const response = await fetch(SHEETS_API_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                    },
                    body: new URLSearchParams({
                        action: 'saveAll',
                        games: JSON.stringify(gameData.games),
                        votes: JSON.stringify(gameData.votes),
                        history: JSON.stringify(gameData.history),
                        settings: JSON.stringify({
                            votingDeadline: gameData.votingDeadline,
                            gameNightDate: gameData.gameNightDate,
                            adminPassword: gameData.adminPassword,
                            manualAssignments: gameData.manualAssignments
                        })
                    }),
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const result = await response.json();
                
                if (!result.success) {
                    throw new Error(result.error || 'Save failed');
                }
                
                console.log('Data saved successfully to Google Sheets');
                showSaveStatus('success', '‚úì Saved');
                isSaving = false;
                
            } catch (error) {
                console.error('Error saving data:', error);
                
                // Retry logic
                if (retryCount < maxRetries) {
                    console.log(`Retrying... (${retryCount + 1}/${maxRetries})`);
                    isSaving = false;
                    await new Promise(resolve => setTimeout(resolve, 2000)); // Wait 2 seconds
                    return saveData(retryCount + 1);
                } else {
                    // All retries failed
                    isSaving = false;
                    const errorMsg = error.name === 'AbortError' 
                        ? 'Save timed out. Check your internet connection.' 
                        : `Save failed: ${error.message}`;
                    
                    showSaveStatus('error', errorMsg);
                    
                    // Add retry button
                    const statusDiv = document.getElementById('saveStatus');
                    const retryBtn = document.createElement('button');
                    retryBtn.className = 'retry-button';
                    retryBtn.textContent = 'Retry';
                    retryBtn.onclick = () => {
                        statusDiv.querySelector('.retry-button')?.remove();
                        saveData(0);
                    };
                    statusDiv.appendChild(retryBtn);
                    
                    alert(`‚ö†Ô∏è Failed to save to Google Sheets after ${maxRetries + 1} attempts.\n\n${errorMsg}\n\nYour changes are still visible to you, but may not be saved. Please check your internet connection and click the "Retry" button in the bottom right.`);
                }
            }
        }
        async function loadData() {
            try {
                console.log('Loading data from Google Sheets...');
                console.log('API URL:', SHEETS_API_URL);
                
                const response = await fetch(SHEETS_API_URL + '?action=getData');
                console.log('Response status:', response.status);
                console.log('Response OK:', response.ok);
                
                const result = await response.json();
                console.log('Result:', result);
                
                if (result.success && result.data) {
                    // Convert votes back to proper format
                    const votes = (result.data.votes || []).map(vote => ({
                        voterName: vote.voterName,
                        choices: [
                            parseInt(vote.choice1),
                            parseInt(vote.choice2),
                            parseInt(vote.choice3)
                        ]
                    }));
                    
                    gameData = {
                        games: result.data.games || [],
                        votes: votes,
                        history: result.data.history || [],
                        votingDeadline: result.data.settings.votingDeadline || getNextTuesday(),
                        gameNightDate: result.data.settings.gameNightDate || getNextWednesday(),
                        adminPassword: result.data.settings.adminPassword || 'admin123'
                    };
                    
                    console.log('Data loaded successfully. Games:', gameData.games.length);
                } else {
                    console.error('Failed to load data:', result);
                    gameData.adminPassword = 'admin123';
                    gameData.votingDeadline = getNextTuesday();
                    gameData.gameNightDate = getNextWednesday();
                            gameData.manualAssignments = {}; // clear manual overrides
}
            } catch (error) {
                console.error('Error loading data:', error);
                console.error('Error details:', {
                    name: error.name,
                    message: error.message,
                    stack: error.stack
                });
                alert('‚ö†Ô∏è Error connecting to Google Sheets.\n\nPlease check:\n1. Your internet connection\n2. The Google Apps Script is deployed correctly\n\nOpen your browser console (F12) for details.');
                gameData.adminPassword = 'admin123';
                gameData.votingDeadline = getNextTuesday();
                gameData.gameNightDate = getNextWednesday();
            }
            updateAllDisplays();
        }

        // Helper function to get next Tuesday
        function getNextTuesday() {
            const today = new Date();
            const dayOfWeek = today.getDay();
            const daysUntilTuesday = (2 - dayOfWeek + 7) % 7 || 7;
            const nextTuesday = new Date(today);
            nextTuesday.setDate(today.getDate() + daysUntilTuesday);
            return nextTuesday.toISOString().split('T')[0];
        }

        // Helper function to get next Wednesday
        function getNextWednesday() {
            const today = new Date();
            const dayOfWeek = today.getDay();
            const daysUntilWednesday = (3 - dayOfWeek + 7) % 7 || 7;
            const nextWednesday = new Date(today);
            nextWednesday.setDate(today.getDate() + daysUntilWednesday);
            return nextWednesday.toISOString().split('T')[0];
        }

        // Admin login
        function adminLogin() {
            const password = document.getElementById('adminPassword').value;
            
            if (password === gameData.adminPassword) {
                isAdminLoggedIn = true;
                document.getElementById('adminLogin').style.display = 'none';
                document.getElementById('adminPanel').style.display = 'block';
                document.getElementById('winnerRecordingSection').style.display = 'block';
                document.getElementById('adminPassword').value = '';
                
                // Show a notice about changing the default password
                if (gameData.adminPassword === 'admin123') {
                    alert('‚ö†Ô∏è You are using the default password "admin123". Please change it below for security!');
                }
            } else {
                alert('Incorrect password');
                document.getElementById('adminPassword').value = '';
            }
        }

        // Admin logout
        function adminLogout() {
            isAdminLoggedIn = false;
            document.getElementById('adminLogin').style.display = 'block';
            document.getElementById('adminPanel').style.display = 'none';
            document.getElementById('winnerRecordingSection').style.display = 'none';
        }

        // Change admin password (optimistic update)
        async function changeAdminPassword() {
            const newPassword = document.getElementById('newAdminPassword').value.trim();
            
            if (!newPassword) {
                alert('Please enter a new password');
                return;
            }
            
            if (newPassword.length < 6) {
                alert('Password must be at least 6 characters long');
                return;
            }
            
            gameData.adminPassword = newPassword;
            document.getElementById('newAdminPassword').value = '';
            alert('Admin password updated successfully!');
            
            // Save in background (don't await)
            saveData();
        }

        // Check if voting is open
        function isVotingOpen() {
            if (!gameData.votingDeadline) return true;
            
            // Parse deadline as local date
            const [year, month, day] = gameData.votingDeadline.split('-').map(Number);
            const deadline = new Date(year, month - 1, day);
            
            // Set deadline to end of day (11:59:59 PM)
            deadline.setHours(23, 59, 59, 999);
            
            const now = new Date();
            return now < deadline;
        }

        // Update voting status display
        function updateVotingStatus() {
            const statusDiv = document.getElementById('votingStatus');
            const warningDiv = document.getElementById('votingWarning');
            const votingDeadlineInput = document.getElementById('votingDeadline');
            const gameNightDateInput = document.getElementById('gameNightDate');
            
            console.log('updateVotingStatus called, deadline:', gameData.votingDeadline);
            
            // Update the input fields with current dates
            if (gameData.votingDeadline) {
                votingDeadlineInput.value = gameData.votingDeadline;
            }
            if (gameData.gameNightDate) {
                gameNightDateInput.value = gameData.gameNightDate;
            }
            
            if (!gameData.votingDeadline) {
                statusDiv.className = 'voting-status voting-open';
                statusDiv.textContent = 'Voting is OPEN (no deadline set)';
                warningDiv.style.display = 'none';
            } else {
                // Parse as local date to avoid timezone issues
                const [year, month, day] = gameData.votingDeadline.split('-').map(Number);
                const deadline = new Date(year, month - 1, day);
                
                console.log('Deadline date object:', deadline);
                const options = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
                const dateStr = deadline.toLocaleDateString('en-US', options);
                
                if (isVotingOpen()) {
                    statusDiv.className = 'voting-status voting-open';
                    statusDiv.textContent = `Voting is OPEN until ${dateStr}`;
                    warningDiv.style.display = 'none';
                } else {
                    statusDiv.className = 'voting-status voting-closed';
                    statusDiv.textContent = `Voting CLOSED on ${dateStr}`;
                    warningDiv.style.display = 'block';
                    warningDiv.textContent = 'Voting is currently closed. Contact the organizer to reopen voting.';
                }
            }
        }

        // Save game night dates (optimistic update)
        async function saveGameNightDates() {
            if (!isAdminLoggedIn) {
                alert('Admin access required');
                return;
            }
            
            const gameNightDate = document.getElementById('gameNightDate').value;
            const votingDeadline = document.getElementById('votingDeadline').value;
            
            if (!gameNightDate || !votingDeadline) {
                alert('Please select both dates');
                return;
            }
            
            gameData.gameNightDate = gameNightDate;
            gameData.votingDeadline = votingDeadline;
            
            // Optimistic update - refresh UI immediately
            displayGameNightInfo();
            updateVotingStatus();
            alert('Dates updated successfully!');
            
            // Save in background (don't await)
            saveData().catch(error => {
                console.error('Failed to save dates:', error);
            });
        }

        // Add a game (optimistic update)
        async function addGame() {
            try {
                console.log('=== ADD GAME STARTED ===');
                
                const ownerName = document.getElementById('ownerName').value.trim();
                const gameName = document.getElementById('gameName').value.trim();
                const bggLink = document.getElementById('bggLink').value.trim();
                const gameLength = document.getElementById('gameLength').value.trim();
                const minPlayers = parseInt(document.getElementById('minPlayers').value);
                const maxPlayers = parseInt(document.getElementById('maxPlayers').value);
                const canTeach = document.getElementById('canTeach').checked;

                console.log('Form values:', { ownerName, gameName, bggLink, gameLength, minPlayers, maxPlayers, canTeach });

                if (!ownerName || !gameName) {
                    alert('Please enter both your name and game name');
                    return;
                }

                if (minPlayers > maxPlayers) {
                    alert('Min players cannot be greater than max players');
                    return;
                }

                // Check if game already exists
                const existingGame = gameData.games.find(g => g.name.toLowerCase() === gameName.toLowerCase());
                
                if (existingGame) {
                    console.log('Game exists, adding owner...');
                    // Add owner to existing game
                    if (!existingGame.owners.find(o => o.name.toLowerCase() === ownerName.toLowerCase())) {
                        existingGame.owners.push({ name: ownerName, canTeach: canTeach });
                        // Update BGG link if provided and not already set
                        if (bggLink && !existingGame.bggLink) {
                            existingGame.bggLink = bggLink;
                        }
                        // Update game length if provided and not already set
                        if (gameLength && !existingGame.gameLength) {
                            existingGame.gameLength = parseInt(gameLength);
                        }
                    } else {
                        alert(`${ownerName} is already listed as an owner of ${gameName}`);
                        return;
                    }
                } else {
                    console.log('Creating new game...');
                    // Create new game
                    const game = {
                        id: Date.now(),
                        name: gameName,
                        bggLink: bggLink || null,
                        gameLength: gameLength ? parseInt(gameLength) : null,
                        owners: [{ name: ownerName, canTeach: canTeach }],
                        minPlayers: minPlayers,
                        maxPlayers: maxPlayers
                    };
                    console.log('New game object:', game);
                    gameData.games.push(game);
                }

                // Clear form
                document.getElementById('ownerName').value = '';
                document.getElementById('gameName').value = '';
                document.getElementById('bggLink').value = '';
                document.getElementById('gameLength').value = '';
                document.getElementById('minPlayers').value = '2';
                document.getElementById('maxPlayers').value = '4';
                document.getElementById('canTeach').checked = false;

                console.log('Form cleared, updating displays...');
                
                // Optimistic update - refresh UI immediately
                updateAllDisplays();
                
                console.log('Starting save...');
                // Save in background (don't await)
                saveData();
                
                console.log('=== ADD GAME COMPLETED ===');
                
            } catch (error) {
                console.error('ERROR IN addGame:', error);
                console.error('Error stack:', error.stack);
                alert(`Error adding game: ${error.message}\n\nCheck console for details.`);
            }
        }

        // Edit BGG link for a game (admin only)
        async function editBGGLink(gameId) {
            if (!isAdminLoggedIn) {
                alert('Admin access required');
                return;
            }

            const game = gameData.games.find(g => g.id === gameId);
            if (!game) return;

            const newLink = prompt(`Enter BoardGameGeek link for "${game.name}":`, game.bggLink || '');
            if (newLink === null) return; // User cancelled

            game.bggLink = newLink.trim() || null;

            // Optimistic update - refresh UI immediately
            displayGameManagement();
            displayVotingGrid();
            
            // Save in background
            saveData();
        }

        // Display game management grid (admin only)
        function displayGameManagement() {
            const gridDiv = document.getElementById('gameManagementGrid');
            
            if (!isAdminLoggedIn) {
                gridDiv.innerHTML = '';
                return;
            }
            
            if (gameData.games.length === 0) {
                gridDiv.innerHTML = '<p style="color: #999;">No games added yet</p>';
                return;
            }

            gridDiv.innerHTML = gameData.games.map(game => {
                const ownersList = game.owners.map(o => 
                    `${o.name}${o.canTeach ? ' (can teach)' : ''}`
                ).join(', ');

                const gameLengthText = game.gameLength ? ` ‚Ä¢ ${game.gameLength} min` : '';
                const bggText = game.bggLink ? ' ‚Ä¢ Has BGG link' : '';

                return `
                    <div class="game-mgmt-item">
                        <div class="game-mgmt-info">
                            <h4>${game.name}</h4>
                            <div class="mgmt-detail">üë• ${game.minPlayers}-${game.maxPlayers} players${gameLengthText}${bggText}</div>
                            <div class="mgmt-detail">üé≤ ${ownersList}</div>
                        </div>
                        <div class="game-mgmt-actions">
                            <button onclick="editBGGLink(${game.id})" style="background: #3498db;">Edit Link</button>
                            <button onclick="deleteGame(${game.id})" class="danger">Delete</button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        // Display game night info
        function displayGameNightInfo() {
            const infoDiv = document.getElementById('gameNightInfo');
            
            // Parse dates as local dates (not UTC) to avoid timezone issues
            const [gnYear, gnMonth, gnDay] = gameData.gameNightDate.split('-').map(Number);
            const gameNightDate = new Date(gnYear, gnMonth - 1, gnDay);
            
            const [vdYear, vdMonth, vdDay] = gameData.votingDeadline.split('-').map(Number);
            const votingDeadline = new Date(vdYear, vdMonth - 1, vdDay);
            
            const gameNightStr = gameNightDate.toLocaleDateString('en-US', { 
                weekday: 'long', 
                year: 'numeric', 
                month: 'long', 
                day: 'numeric' 
            });
            
            const votingDeadlineStr = votingDeadline.toLocaleDateString('en-US', { 
                weekday: 'long', 
                year: 'numeric', 
                month: 'long', 
                day: 'numeric' 
            });
            
            infoDiv.innerHTML = `
                <h3>üìÖ Next Game Night</h3>
                <div class="info-detail"><strong>${gameNightStr}</strong></div>
                <div class="info-detail" style="margin-top: 10px;">Voting closes: ${votingDeadlineStr}</div>
            `;
        }

        // Delete a game (admin only, optimistic update)
        async function deleteGame(gameId) {
            if (!isAdminLoggedIn) {
                alert('Admin access required');
                return;
            }

            const game = gameData.games.find(g => g.id === gameId);
            if (!game) return;

            if (!confirm(`Are you sure you want to delete "${game.name}"?`)) {
                return;
            }

            // Remove the game
            gameData.games = gameData.games.filter(g => g.id !== gameId);

            // Remove any votes for this game
            gameData.votes = gameData.votes.map(vote => {
                const newChoices = vote.choices.filter(choice => choice !== gameId);
                // If we removed choices, we need to handle that
                if (newChoices.length < vote.choices.length) {
                    // Pad with null values if needed
                    while (newChoices.length < 3) {
                        newChoices.push(null);
                    }
                }
                return {
                    ...vote,
                    choices: newChoices
                };
            }).filter(vote => vote.choices.some(c => c !== null)); // Remove votes with no valid choices

            // Optimistic update - refresh UI immediately
            updateAllDisplays();
            
            // Save in background (don't await)
            saveData();
        }

        // Display games list
        
        // Admin: assign/unassign a player to a specific game (manual override)
        async function adminAssignPlayer(nameKey, gameId) {
            if (!isAdminLoggedIn) {
                alert('Admin access required');
                return;
            }
            if (!gameId) {
                alert('Pick a game to assign this player to.');
                return;
            }

            const gid = parseInt(gameId);
            const game = gameData.games.find(g => g.id === gid);
            if (!game) {
                alert('Game not found');
                return;
            }

            if (!gameData.manualAssignments || typeof gameData.manualAssignments !== 'object') {
                gameData.manualAssignments = {};
            }

            // One game per person: overwrite any existing assignment
            gameData.manualAssignments[nameKey] = gid;

            updateAllDisplays();
            saveData();
        }

        async function adminUnassignPlayer(nameKey) {
            if (!isAdminLoggedIn) {
                alert('Admin access required');
                return;
            }

        // Admin: force a player to remain unassigned (won't be auto-seated)
        async function adminForceUnassigned(nameKey) {
            if (!isAdminLoggedIn) { alert('Admin access required'); return; }
            if (!gameData.manualAssignments || typeof gameData.manualAssignments !== 'object') {
                gameData.manualAssignments = {};
            }
            gameData.manualAssignments[nameKey] = -1; // special value = force unassigned
            updateAllDisplays();
            saveData();
        }

        // Admin: clear manual override (returns player to automatic seating)
        async function adminClearManual(nameKey) {
            if (!isAdminLoggedIn) { alert('Admin access required'); return; }
            if (gameData.manualAssignments && Object.prototype.hasOwnProperty.call(gameData.manualAssignments, nameKey)) {
                delete gameData.manualAssignments[nameKey];
                updateAllDisplays();
                saveData();
            }
        }

        // Admin: apply move command from UI
        async function adminApplyMove(nameKey, selectElId) {
            if (!isAdminLoggedIn) { alert('Admin access required'); return; }
            const el = document.getElementById(selectElId);
            if (!el) return;
            const val = el.value;
            if (!val) return;

            if (val === 'AUTO') return adminClearManual(nameKey);
            if (val === 'UNASSIGN') return adminForceUnassigned(nameKey);
            return adminAssignPlayer(nameKey, val);
        }

            if (gameData.manualAssignments && gameData.manualAssignments[nameKey]) {
                delete gameData.manualAssignments[nameKey];
                updateAllDisplays();
                saveData();
            }
        }

// Display voting grid
        function displayVotingGrid() {
            const gridDiv = document.getElementById('votingGrid');
            const counterDiv = document.getElementById('selectionCounter');
            
            // Update selection counter
            const selectedCount = selectedVotes.filter(id => id !== null).length;
            const remaining = 3 - selectedCount;
            
            if (remaining > 0) {
                counterDiv.className = 'selection-counter';
                counterDiv.textContent = `You need to select ${remaining} more game${remaining !== 1 ? 's' : ''}`;
            } else {
                counterDiv.className = 'selection-counter complete';
                counterDiv.textContent = '‚úì Ready to submit! You\'ve selected 3 games.';
            }
            
            if (gameData.games.length === 0) {
                gridDiv.innerHTML = '<p style="color: #999;">No games available to vote on</p>';
                return;
            }

            gridDiv.innerHTML = gameData.games.map(game => {
                const ownersList = game.owners.map(o => 
                    `${o.name}${o.canTeach ? ' üë®‚Äçüè´' : ''}`
                ).join(', ');

                const bggLinkHtml = game.bggLink 
                    ? `<div class="card-detail"><a href="${game.bggLink}" target="_blank" style="color: #667eea;" onclick="event.stopPropagation();">üìñ View Rules</a></div>` 
                    : '';

                const gameLengthHtml = game.gameLength
                    ? `<div class="card-detail">‚è±Ô∏è ${game.gameLength} min</div>`
                    : '';

                // Check if this game is selected
                const rank = selectedVotes.indexOf(game.id) + 1;
                const selectedClass = rank > 0 ? 'selected' : '';

                return `
                    <div class="voting-card ${selectedClass}" onclick="selectGame(${game.id})">
                        <div class="rank-badge">${rank}</div>
                        <h4>${game.name}</h4>
                        <div class="card-detail">üë• ${game.minPlayers}-${game.maxPlayers} players</div>
                        ${gameLengthHtml}
                        <div class="card-detail">üé≤ ${ownersList}</div>
                        ${bggLinkHtml}
                    </div>
                `;
            }).join('');
        }

        // Select a game for voting
        function selectGame(gameId) {
            const currentIndex = selectedVotes.indexOf(gameId);
            
            if (currentIndex >= 0) {
                // Game is already selected - deselect it
                selectedVotes[currentIndex] = null;
            } else {
                // Find the first available slot
                const emptySlot = selectedVotes.indexOf(null);
                if (emptySlot >= 0) {
                    selectedVotes[emptySlot] = gameId;
                } else {
                    alert('You can only select 3 games. Deselect one first.');
                    return;
                }
            }
            
            // Refresh the grid
            displayVotingGrid();
        }

        // Update vote dropdowns (legacy - keeping for backward compatibility with winner dropdown)
        function updateVoteDropdowns() {
            // Update winner dropdown
            const winnerSelect = document.getElementById('winnerGame');
            const currentWinnerValue = winnerSelect.value;
            winnerSelect.innerHTML = '<option value="">Select a game</option>';
            
            const topGames = calculateTopGames();
            topGames.forEach(gameResult => {
                const option = document.createElement('option');
                option.value = gameResult.game.id;
                option.textContent = gameResult.game.name;
                winnerSelect.appendChild(option);
            });
            
            winnerSelect.value = currentWinnerValue;
        }

        // Submit vote (optimistic update)
        async function submitVote() {
            if (!isVotingOpen()) {
                alert('Voting is currently closed!');
                return;
            }

            const voterName = document.getElementById('voterName').value.trim();

            if (!voterName) {
                alert('Please enter your name');
                return;
            }

            // Check if user selected 3 games
            const validChoices = selectedVotes.filter(id => id !== null);
            if (validChoices.length !== 3) {
                alert('Please select exactly 3 games');
                return;
            }

            // Remove existing vote from this person
            gameData.votes = gameData.votes.filter(v => v.voterName.toLowerCase() !== voterName.toLowerCase());

            // Add new vote
            const vote = {
                voterName: voterName,
                choices: [...selectedVotes]
            };

            gameData.votes.push(vote);

            // Clear form and selections
            document.getElementById('voterName').value = '';
            selectedVotes = [null, null, null];

            // Optimistic update - refresh UI immediately
            updateAllDisplays();
            alert('Vote submitted successfully!');
            
            // Save in background (don't await)
            saveData();
        }

        // Calculate top games with spillover
        function calculateTopGames() {
            if (gameData.games.length === 0 || gameData.votes.length === 0) {
                lastSeatingState = { unassigned: [], seatNotes: {} };
                return [];
            }

            function normalizeName(name) {
                return String(name || '').trim().toLowerCase();
            }

            function stableHash(str) {
                // Simple deterministic hash (djb2)
                let h = 5381;
                for (let i = 0; i < str.length; i++) {
                    h = ((h << 5) + h) + str.charCodeAt(i);
                    h = h >>> 0; // unsigned
                }
                return h;
            }

            function deterministicSortApplicants(applicants, gameId, seed) {
                // Stable tie-breaker: sort by hash(seed + voterKey + gameId)
                const s = String(seed || '');
                return applicants.sort((a, b) => {
                    const ha = stableHash(`${s}|${gameId}|${a.key}`);
                    const hb = stableHash(`${s}|${gameId}|${b.key}`);
                    if (ha !== hb) return ha - hb;
                    return a.key.localeCompare(b.key);
                });
            }

            function playerCountTarget(totalPlayers) {
                if (totalPlayers <= 6) return 1;
                if (totalPlayers <= 10) return 2;
                return 3;
            }

            // Build unique voter list
            const voters = [];
            const seen = new Set();
            for (const v of gameData.votes) {
                const key = normalizeName(v.voterName);
                if (!key || seen.has(key)) continue;
                seen.add(key);
                const choices = (v.choices || []).filter(id => id != null);
                voters.push({ key, name: String(v.voterName).trim(), choices });
            }

            if (voters.length === 0) {
                lastSeatingState = { unassigned: [], seatNotes: {} };
                return [];
            }

            // Score games (used only for candidate pool ordering + display)
            const scoreByGame = {};
            for (const g of gameData.games) scoreByGame[g.id] = 0;

            for (const v of voters) {
                for (let i = 0; i < 3; i++) {
                    const gameId = v.choices[i];
                    if (gameId == null) continue;
                    const points = [3, 2, 1][i];
                    scoreByGame[gameId] = (scoreByGame[gameId] || 0) + points;
                }
            }

            const scoredGames = gameData.games
                .map(g => ({ game: g, score: scoreByGame[g.id] || 0 }))
                .filter(x => x.score > 0)
                .sort((a, b) => b.score - a.score);

            if (scoredGames.length === 0) {
                lastSeatingState = { unassigned: voters.map(v => v.name), seatNotes: {} };
                return [];
            }

            const seatSeed = gameData.gameNightDate || gameData.votingDeadline || '';

            const CANDIDATE_POOL = Math.min(6, scoredGames.length);
            const candidatePoolIds = scoredGames.slice(0, CANDIDATE_POOL).map(x => x.game.id);

            // --- Strong #1 soft protection ---
            // Identify games with strong #1 support (>=2 first-choice voters),
            // that can form a valid table (meets minPlayers) and can seat all their #1 voters (<= maxPlayers).
            // We'll apply a penalty if an evaluated subset excludes these games, instead of hard-forcing them.
            const firstChoiceCount = {};
            for (const g of gameData.games) firstChoiceCount[g.id] = 0;
            for (const v of voters) {
                const firstId = v.choices[0];
                if (firstId != null) firstChoiceCount[firstId] = (firstChoiceCount[firstId] || 0) + 1;
            }

            const strongFirstChoiceIds = gameData.games
                .filter(g => {
                    const c = firstChoiceCount[g.id] || 0;
                    const minP = g.minPlayers || 0;
                    const maxP = g.maxPlayers || 0;
                    return c >= 2 && c >= minP && c <= maxP;
                })
                .map(g => g.id);

            // Ensure strong #1 games appear in the candidate pool even if their point score is lower.
            strongFirstChoiceIds.forEach(id => {
                if (!candidatePoolIds.includes(id)) candidatePoolIds.push(id);
            });

            function strongFirstExclusionPenalty(activeIds) {
                const active = new Set(activeIds);
                let penalty = 0;
                for (const v of voters) {
                    const firstId = v.choices[0];
                    if (firstId != null && strongFirstChoiceIds.includes(firstId) && !active.has(firstId)) {
                        penalty += 5; // strong penalty per harmed voter (tunable)
                    }
                }
                return penalty;
            }

            function runSeating(activeIds) {
                const activeSet = new Set(activeIds);

                const assignedByGame = {};
                const spillWantedByGame = {};
                const seatNotes = {}; // voterKey -> note
                for (const id of activeIds) {
                    assignedByGame[id] = [];
                    spillWantedByGame[id] = [];
                }

                const assignedGameByVoter = new Map();

                let unassigned = voters.map(v => ({
                    ...v,
                    choices: v.choices.filter(id => activeSet.has(id))
                }));

                // Manual assignments first
                const manual = (gameData.manualAssignments && typeof gameData.manualAssignments === 'object')
                    ? gameData.manualAssignments
                    : {};

                if (Object.keys(manual).length > 0) {
                    const stillUnassigned = [];
                    for (const v of unassigned) {
                        const forcedGameId = manual[v.key];

                        if (forcedGameId === -1) {
                            seatNotes[v.key] = 'Admin marked as unassigned';
                            stillUnassigned.push(v);
                            continue;
                        }

                        if (forcedGameId && activeSet.has(forcedGameId)) {
                            const game = gameData.games.find(g => g.id === forcedGameId);
                            const seatsLeft = game ? Math.max(0, (game.maxPlayers || 0) - assignedByGame[forcedGameId].length) : 0;
                            if (seatsLeft > 0) {
                                assignedByGame[forcedGameId].push({ name: v.name, rank: 0 }); // 0 = admin assigned
                                assignedGameByVoter.set(v.key, forcedGameId);
                            } else {
                                seatNotes[v.key] = `Admin assigned to ${game ? game.name : 'a game'}, but it was full`;
                                stillUnassigned.push(v);
                            }
                        } else {
                            stillUnassigned.push(v);
                        }
                    }
                    unassigned = stillUnassigned;
                }

                // Rank rounds: 1st, 2nd, 3rd
                for (let rank = 0; rank < 3; rank++) {
                    const applicantsByGame = {};
                    for (const id of activeIds) applicantsByGame[id] = [];

                    const stillUnassigned = [];
                    for (const v of unassigned) {
                        const desired = v.choices[rank];
                        if (desired != null && activeSet.has(desired)) {
                            applicantsByGame[desired].push(v);
                        } else {
                            stillUnassigned.push(v);
                        }
                    }

                    for (const id of activeIds) {
                        const game = gameData.games.find(g => g.id === id);
                        if (!game) continue;

                        const applicants = applicantsByGame[id];
                        if (!applicants || applicants.length === 0) continue;

                        deterministicSortApplicants(applicants, id, seatSeed);

                        const seatsLeft = Math.max(0, (game.maxPlayers || 0) - assignedByGame[id].length);
                        const winners = applicants.slice(0, seatsLeft);
                        const losers = applicants.slice(seatsLeft);

                        for (const w of winners) {
                            assignedByGame[id].push({ name: w.name, rank: rank + 1 });
                            assignedGameByVoter.set(w.key, id);
                        }

                        for (const l of losers) {
                            spillWantedByGame[id].push({ name: l.name, wantedRank: rank + 1, voterKey: l.key });
                            stillUnassigned.push(l);
                        }
                    }

                    unassigned = stillUnassigned;
                }

                return { assignedByGame, unassigned, spillWantedByGame, assignedGameByVoter, seatNotes };
            }

            function validateSeating(activeIds, seating) {
                // Hard reject only truly empty tables; treat minPlayers as a soft constraint (scored later).
                for (const id of activeIds) {
                    const assignedCount = seating.assignedByGame[id]?.length || 0;
                    if (assignedCount === 0) return false;
                }
                return true;
            }

            function outcomeMetrics(activeIds, seating) {
                let totalAssigned = 0;
                let first = 0, second = 0, third = 0, manual = 0;
                let belowMin = 0;

                for (const id of activeIds) {
                    const game = gameData.games.find(g => g.id === id);
                    const rows = seating.assignedByGame[id] || [];
                    totalAssigned += rows.length;

                    const minP = game?.minPlayers || 0;
                    if (minP > 0 && rows.length > 0 && rows.length < minP) belowMin++;

                    for (const r of rows) {
                        if (r.rank === 0) manual++;
                        else if (r.rank === 1) first++;
                        else if (r.rank === 2) second++;
                        else if (r.rank === 3) third++;
                    }
                }

                const unassignedCount = seating.unassigned.length;

                return { 
                    totalAssigned, first, second, third, manual, 
                    unassignedCount,
                    belowMin,
                    gameCount: activeIds.length
                };
            }

            function betterOutcome(a, b) {
                if (!b) return true;

                // 1) Primary: minimize unassigned (seat everyone if possible)
                if (a.unassignedCount !== b.unassignedCount) return a.unassignedCount < b.unassignedCount;

                // 2) Strong #1 soft protection: avoid excluding strong #1 games (penalize per harmed voter)
                if (a.firstExclusionPenalty !== b.firstExclusionPenalty) return a.firstExclusionPenalty < b.firstExclusionPenalty;

                // 3) Prefer fewer tables when outcomes are otherwise similar
                if (a.gameCount !== b.gameCount) return a.gameCount < b.gameCount;

                // 4) Prefer meeting minPlayers when possible (soft)
                if (a.belowMin !== b.belowMin) return a.belowMin < b.belowMin;

                // 5) Then maximize 1st/2nd choices
                if (a.first !== b.first) return a.first > b.first;
                if (a.second !== b.second) return a.second > b.second;

                // 6) Finally minimize 3rd-choice assignments
                if (a.third !== b.third) return a.third < b.third;

                // 7) Tie-break: maximize seated people
                if (a.totalAssigned !== b.totalAssigned) return a.totalAssigned > b.totalAssigned;

                return false;
            }

            function combinations(arr, k) {
                const out = [];
                function rec(start, chosen) {
                    if (chosen.length === k) {
                        out.push(chosen.slice());
                        return;
                    }
                    for (let i = start; i < arr.length; i++) {
                        chosen.push(arr[i]);
                        rec(i + 1, chosen);
                        chosen.pop();
                    }
                }
                rec(0, []);
                return out;
            }

            const maxK = Math.min(3, candidatePoolIds.length);
            let best = null;

            // Try 1..maxK games and pick the best overall seating outcome.
            for (let k = 1; k <= maxK; k++) {
                const subsets = combinations(candidatePoolIds, k);
                for (const subsetIds of subsets) {
                    const seating = runSeating(subsetIds);
                    if (!validateSeating(subsetIds, seating)) continue;

                    const metrics = outcomeMetrics(subsetIds, seating);
                    if (betterOutcome(metrics, best?.metrics)) {
                        best = { ids: subsetIds, seating, metrics };
                    }
                }
            }

            // Fallback if no valid subset (rare): just pick top scored game(s)
            if (!best) {
                const fallbackIds = candidatePoolIds.slice(0, 1);
                const seating = runSeating(fallbackIds);
                best = { ids: fallbackIds, seating, metrics: outcomeMetrics(fallbackIds, seating) };
            }

            const chosenIds = best.ids;
            const chosenSeating = best.seating;

            lastSeatingState = {
                unassigned: chosenSeating.unassigned.map(v => v.name),
                seatNotes: chosenSeating.seatNotes || {}
            };

            function gameNameById(id) {
                const g = gameData.games.find(x => x.id === id);
                return g ? g.name : 'another game';
            }

            const overflowByGame = {};
            for (const id of chosenIds) overflowByGame[id] = [];

            for (const id of chosenIds) {
                const wanted = chosenSeating.spillWantedByGame[id] || [];
                const seenSpill = new Set();

                for (const w of wanted) {
                    const k = normalizeName(w.name);
                    if (seenSpill.has(k)) continue;
                    seenSpill.add(k);

                    const assignedId = chosenSeating.assignedGameByVoter.get(w.voterKey);
                    if (assignedId && assignedId !== id) {
                        overflowByGame[id].push(`${w.name} (moved to ${gameNameById(assignedId)})`);
                    } else if (!assignedId) {
                        overflowByGame[id].push(`${w.name} (no available slot)`);
                    }
                }
            }

            const results = chosenIds
                .map(id => {
                    const game = gameData.games.find(g => g.id === id);
                    const assigned = (chosenSeating.assignedByGame[id] || [])
                        .slice()
                        .sort((a, b) => (a.rank - b.rank) || a.name.localeCompare(b.name))
                        .map(x => x.name);

                    return {
                        game,
                        score: scoreByGame[id] || 0,
                        voters: [],
                        assignedPlayers: assigned,
                        overflowPlayers: overflowByGame[id] || []
                    };
                })
                .filter(r => r.game)
                .sort((a, b) => b.score - a.score);

            return results;
        }

        // Display top games
        function displayTopGames() {
            const topGamesDiv = document.getElementById('topGames');
            const topGames = calculateTopGames();

            if (topGames.length === 0) {
                topGamesDiv.innerHTML = '<p style="color: #999;">No votes yet</p>';
                return;
            }

            topGamesDiv.innerHTML = topGames.map((gameResult, index) => {
                const ownersList = gameResult.game.owners.map(o => 
                    `${o.name}${o.canTeach ? ' üë®‚Äçüè´' : ''}`
                ).join(', ');

                const players = gameResult.assignedPlayers || [];
                const overflow = gameResult.overflowPlayers || [];

                return `
                    <div class="game-item" style="border-left-color: ${['#ffd700', '#c0c0c0', '#cd7f32'][index]};">
                        <h3>${index + 1}. ${gameResult.game.name} (${gameResult.score} points)</h3>
                        <div class="game-detail">Brought by: ${ownersList}</div>
                        <div class="game-detail">Players: ${gameResult.game.minPlayers}-${gameResult.game.maxPlayers}</div>
                        <div class="game-detail">
                            <strong>Playing (${players.length}/${gameResult.game.maxPlayers}):</strong>
                            <div class="player-list">
                                ${players.map(p => `<span class="player-badge">${p}</span>`).join('')}
                            </div>
                        </div>
                        ${isAdminLoggedIn && players.length > 0 ? `
                            <div style="margin-top:10px; padding-top:10px; border-top:1px solid #e0e0e0;">
                                <div style="font-weight:600; color:#667eea; margin-bottom:8px;">Admin: Move players</div>
                                ${players.map(p => {
                                    const key = p.trim().toLowerCase();
                                    const selectId = `move_${gameResult.game.id}_${key}`.replace(/[^a-z0-9_]/g,'_');
                                    const options = topGames.map(g => {
                                        const selected = (g.game.id === gameResult.game.id) ? ' selected' : '';
                                        return `<option value="${g.game.id}"${selected}>${g.game.name}</option>`;
                                    }).join('');
                                    return `
                                        <div style="display:flex; gap:8px; align-items:center; margin:6px 0;">
                                            <div style="flex:1; color:#333;">${p}</div>
                                            <select id="${selectId}" style="min-width:240px;">
                                                ${options}
                                                <option value="UNASSIGN">‚Äî Force Unassigned ‚Äî</option>
                                                <option value="AUTO">‚Äî Clear Override (Auto) ‚Äî</option>
                                            </select>
                                            <button onclick="adminApplyMove('${key}', '${selectId}')" style="background:#3498db; padding:6px 12px; font-size:12px;">Apply</button>
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                        ` : ``}
                        ${overflow.length > 0 ? `
                            <div class="overflow-indicator">
                                Spillover: ${overflow.join(', ')}
                            </div>
                        ` : ''}
                    </div>
                `;
            }).join('');
        
            // Unassigned players + admin assignment controls
            const unassigned = (lastSeatingState && lastSeatingState.unassigned) ? lastSeatingState.unassigned : [];
            if (unassigned.length > 0) {
                const gameOptions = topGames.map(g => `<option value="${g.game.id}">${g.game.name}</option>`).join('');

                const rows = unassigned.map(name => {
                    const key = name.trim().toLowerCase();
                    const note = (lastSeatingState.seatNotes && lastSeatingState.seatNotes[key]) ? lastSeatingState.seatNotes[key] : '';
                    if (isAdminLoggedIn) {
                        return `
                            <div class="game-mgmt-item" style="border-left-color:#e74c3c;">
                                <div class="game-mgmt-info">
                                    <h4>‚ùó ${name}</h4>
                                    ${note ? `<div class="mgmt-detail" style="color:#c0392b;">${note}</div>` : ''}
                                    <div class="mgmt-detail">Not assigned yet</div>
                                </div>
                                <div class="game-mgmt-actions">
                                    <select id="assign_${key}" style="min-width:220px;">
                                        <option value="">Pick a game‚Ä¶</option>
                                        ${gameOptions}
                                    </select>
                                    <button onclick="adminAssignPlayer('${key}', document.getElementById('assign_${key}').value)" style="background:#3498db;">Assign</button>
                                    <button onclick="adminClearManual('${key}')" class="secondary" style="padding:6px 12px; font-size:12px;">Auto</button>
                                    <button onclick="adminForceUnassigned('${key}')" class="danger" style="padding:6px 12px; font-size:12px;">Keep Unassigned</button>
                                </div>
                            </div>
                        `;
                    }
                    return `
                        <div class="history-item" style="border-left:4px solid #e74c3c;">
                            <h4>‚ùó Unassigned: ${name}</h4>
                            <div class="game-detail">Waiting for organizer assignment</div>
                        </div>
                    `;
                }).join('');

                topGamesDiv.innerHTML += `
                    <div style="margin-top:20px;">
                        <h3 style="color:#e74c3c; margin-bottom:10px;">Unassigned Players</h3>
                        <div class="${isAdminLoggedIn ? 'game-management-grid' : ''}">
                            ${rows}
                        </div>
                    </div>
                `;
            }
}

        // Record winner (optimistic update)
        async function recordWinner() {
            if (!isAdminLoggedIn) {
                alert('Admin access required');
                return;
            }
            
            const gameId = document.getElementById('winnerGame').value;
            const winnerName = document.getElementById('winnerName').value.trim();
            const winnerDate = document.getElementById('winnerDate').value;

            if (!gameId || !winnerName || !winnerDate) {
                alert('Please fill in all fields');
                return;
            }

            const game = gameData.games.find(g => g.id === parseInt(gameId));
            if (!game) {
                alert('Game not found');
                return;
            }

            const historyEntry = {
                id: Date.now(),
                gameName: game.name,
                winner: winnerName,
                date: winnerDate
            };

            gameData.history.push(historyEntry);

            // Clear form
            document.getElementById('winnerGame').value = '';
            document.getElementById('winnerName').value = '';
            document.getElementById('winnerDate').value = '';

            // Optimistic update - refresh UI immediately
            displayHistory();
            alert('Winner recorded successfully!');
            
            // Save in background (don't await)
            saveData();
        }

        // Display history
        function displayHistory() {
            const historyDiv = document.getElementById('historyList');
            
            if (gameData.history.length === 0) {
                historyDiv.innerHTML = '<p style="color: #999;">No game history yet</p>';
                return;
            }

            // Sort by date descending
            const sortedHistory = [...gameData.history].sort((a, b) => 
                new Date(b.date) - new Date(a.date)
            );

            historyDiv.innerHTML = sortedHistory.map(entry => {
                const date = new Date(entry.date);
                const dateStr = date.toLocaleDateString('en-US', { 
                    weekday: 'long', 
                    year: 'numeric', 
                    month: 'long', 
                    day: 'numeric' 
                });

                return `
                    <div class="history-item">
                        <h4>üèÜ ${entry.gameName}</h4>
                        <div class="game-detail">Winner: <strong>${entry.winner}</strong></div>
                        <div class="game-detail">Date: ${dateStr}</div>
                    </div>
                `;
            }).join('');
        }

        // Reset for new week (optimistic update)
        async function resetForNewWeek() {
            if (!isAdminLoggedIn) {
                alert('Admin access required');
                return;
            }
            
            if (!confirm('This will clear all games and votes for the new week. History will be preserved. Continue?')) {
                return;
            }

            gameData.games = [];
            gameData.votes = [];
            gameData.votingDeadline = getNextTuesday();
            gameData.gameNightDate = getNextWednesday();

            // Optimistic update - refresh UI immediately
            updateAllDisplays();
            alert('Reset complete! Ready for a new week.');
            
            // Save in background (don't await)
            saveData();
        }

        // Update all displays
        function updateAllDisplays() {
            displayGameNightInfo();
            displayVotingGrid();
            displayGameManagement();
            updateVoteDropdowns();
            displayTopGames();
            displayHistory();
            updateVotingStatus();
            
            // Set today's date as default for winner recording
            const today = new Date().toISOString().split('T')[0];
            document.getElementById('winnerDate').value = today;
        }

        // Initialize on load
        window.addEventListener('load', () => {
            loadData();
            
            // Auto-refresh data every 10 seconds to stay in sync
            setInterval(async () => {
                if (!isAdminLoggedIn) { // Don't refresh while admin is making changes
                    await loadData();
                }
            }, 10000);
        });
    </script>
</body>
</html>
